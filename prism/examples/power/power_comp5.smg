//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
// Electrical Starting, Generation, Conversion and Distribution System Architecture for //
//     a More Electric Vehicle                                                          //
//                                                                                      //
// Modelled after European Patent EP 1 792 379 B1, by Rodney G. Michalko                //
//                                                                                      //
// Author: Clemens Wiltsche, University of Oxford, 2014 (clemens.wiltsche@cs.ox.ac.uk)  //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

// Model Assumptions:
// * Game proceeds in rounds: generator status changes then the switch intention changes,
//       constituting 1 + 1 time steps
// * Only one contactor switch intention per subsystem may change at any one time
// * Generators may fail independently, also several at a time, but per subsystem at least
//       one generator must be operational at any time.
// * Interfaces:
//    + The component controlling the connector only switches it on if the component
//          itself is healthy. There may be a brief interruption until the intention
//          of switching is put into practice.
//    + The component receiving a connector status ensures non-paralleling of sources:
//          if the connector is on, the bus it is connected to must receive power over
//          the interface, but if the connector is off, it can do as it wishes.
//    + Together these assumptions imply that power only flows from the controlling
//          component to the receiving component, i.e. is unidirectional.

smg

/////////////////////////////// TOP-LEVEL SYTEM (200) ////////////////////////////////////

system "MEV"
	//"HVAC_LEFT" || "HVAC_RIGHT"
	"HVAC_LEFT"
	//"HVAC_RIGHT"
	//"HVDC_RIGHT"
	// "HVAC_LEFT" || "HVAC_RIGHT" || "HVDC_RIGHT"
endsystem

// delays
const gen_time = 1; // every 1 time unit, the generator status is sampled

// connector delay dynamics
const double d0 = 1.0; // switch immediately
const double d1 = 0.0; // switch after one time unit
const double d2 = 0.0; //1.0 - d0 - d1; // switch after two time units


//////////////////////////// HIGH VOLATAGE AC, LEFT (210a) ///////////////////////////////

// since the games are irreducible, and all state have the same period,
// we can use average rewards nstead of ratio rewards, and multiply by
// the period. Note that both states and transitions count.

const int ratio_factor = 7*2;

system "HVAC_LEFT"
       C1_switch || C2_switch || C3_switch || C4_switch || GEN_LEFT || HVAC_LEFT
endsystem

const C1_init = 1;
const C2_init = 0;
const C3_init = 1;
const C4_init = 0;

module C1_switch
        C1 : [0..1] init C1_init; // connector status for C1
	C1_int : [0..1] init C1_init; // intention for C1
	C1_count : [0..2] init 0; // counter for C1 intention to be put into practice

	// change intention to switch off
	[c1] C1_int!=0 -> d0 : (C1_int'=0) & (C1_count'=0) & (C1'=0)
		        + d1 : (C1_int'=0) & (C1_count'=1)
		        + d2 : (C1_int'=0) & (C1_count'=2);
	// change intention to switch on
	[c1] C1_int!=1 -> d0 : (C1_int'=1) & (C1_count'=0) & (C1'=1)
		        + d1 : (C1_int'=1) & (C1_count'=1)
		        + d2 : (C1_int'=1) & (C1_count'=2);

	// decrease count once per round
	[c2] C1_count>1 -> (C1_count'=C1_count-1);
	[c3] C1_count>1 -> (C1_count'=C1_count-1);
	[c4] C1_count>1 -> (C1_count'=C1_count-1);
	[nc_left] C1_count>1 -> (C1_count'=C1_count-1);

	// count goes to zero - set connector status to intention
	[c2] C1_count<=1 -> (C1_count'=0) & (C1'=C1_int);
	[c3] C1_count<=1 -> (C1_count'=0) & (C1'=C1_int);
	[c4] C1_count<=1 -> (C1_count'=0) & (C1'=C1_int);
	[nc_left] C1_count<=1 -> (C1_count'=0) & (C1'=C1_int);
endmodule
module C2_switch = C1_switch [C1=C2, C1_int=C2_int, C1_count=C2_count, C1_init=C2_init, c1=c2, c2=c1] endmodule
module C3_switch = C1_switch [C1=C3, C1_int=C3_int, C1_count=C3_count, C1_init=C3_init, c1=c3, c3=c1] endmodule
module C4_switch = C1_switch [C1=C4, C1_int=C4_int, C1_count=C4_count, C1_init=C4_init, c1=c4, c4=c1] endmodule

module GEN_LEFT
	// generators
        G224a : [0..1] init 1; // 224a
        G252a : [0..1] init 1; // 252a

	[gen_left] true -> (G224a'=1) & (G252a'=1); // both generators work
	[gen_left] true -> (G224a'=1) & (G252a'=0); // 224a fails
	[gen_left] true -> (G224a'=0) & (G252a'=1); // 252a fails
endmodule

// interface I1 (left to right direction)
formula i1l_pow = C4=1 & B214a2=1;
formula i1l_off = (C4=0 & C4_int=0) | (C3=0 & C3_int=0 & C2=0 & C2_int=0) | (C1=0 & C1_int=0 & C2=0 & C2_int=0);
formula i1l_unsafe = !i1l_pow & !i1l_off;

// interface I2 (unidirectional, to RU242a1, paralleling allowed)
formula i2_pow = B214a1=1;
formula i2_off = !i2_pow;

// interface I3 (unidirectional, to RU242a2, paralleling allowed)
formula i3_pow = B214a2=1;
formula i3_off = !i3_pow;

module HVAC_LEFT
	// buses - dependent
	B214a1 : [0..1] init 1; // 214a-1
	B214a2 : [0..1] init 1; // 214a-2

	// status of power delivered over interface I1 to left side
	I1_left : [0..2] init 0;

	// players / stages:
	// 1: player 1 sets connectors --------------------------------------------------------------|
	// 2: player 2 communicates connector 4 status over interfaces                               |
	// 5: player 2 sets generator status                                                         | main loop (go to 1 from 7)
	// 6: player 2 receives communication from other interfaces                                  |
	// 7: player 2 performs tau for normal form -------------------------------------------------|
	pL : [1..7] init 6;

	// 1: connectors
	[nc_left!] pL=1 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);
	[c1!] pL=1 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);
	[c2!] pL=1 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);
	[c3!] pL=1 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);
	[c4!] pL=1 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);

	// 2: interfaces - output
	[i1l_pow?] pL=2 & i1l_pow -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=3);
	[i1l_off?] pL=2 & i1l_off -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=3);
	[i1l_unsafe?] pL=2 & i1l_unsafe -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=3);

	[i2_pow?] pL=3 & i2_pow -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);
	[i2_off?] pL=3 & i2_off -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);

	[i3_pow?] pL=4 & i3_pow -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=5);
	[i3_off?] pL=4 & i3_off -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=5);

	// 5: generators
	[gen_left?] pL=5 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=6);

	// 6: interfaces - input
	[i1r_pow?] pL=6 -> (I1_left'=1) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);
	[i1r_off?] pL=6 -> (I1_left'=0) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);
	[i1r_unsafe?] pL=6 -> (I1_left'=2) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);

	// 7: tau for normal form
	[tau?] pL=7 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=1);
endmodule


// SAFETY SPECIFICATIONS - HVAC LEFT

// no paralleling of sources
formula safe_left = (C1=0 | C3=0 | C2=0) &
		    (C1=0 | C3=0 | C4=0 | I1_left=0) &
		    (C2=0 | C4=0 | I1_left=0);

// buses
formula bus_214a1 = (G224a=1 & C1=1)
	          | (B214a2=1 & G252a=1 & C3=1 & C2=1)
	          | (B214a2=1 & C3=1 & C4=1 & I1_left=1)
	          ? 1 : 0;
formula bus_214a2 = (B214a1=1 & G224a=1 & C1=1 & C3=1)
	          | (G252a=1 & C2=1)
	          | (C4=1 & I1_left=1)
                  ? 1 : 0;

// REWARDS - HVAC LEFT

rewards "i1l_pow" [i1l_pow] true : gen_time*ratio_factor; endrewards // left side powers interface 1
rewards "i1l_off" [i1l_off] true : gen_time*ratio_factor; endrewards // left side isolates interface 1
rewards "idcl_pow" [i2_pow] true : gen_time*ratio_factor; [i3_pow] true : gen_time*ratio_factor; endrewards // power is transferred over DC interface i2 or i3
rewards "fail_l" [gen_left] !safe_left : 1*ratio_factor; endrewards // left side fails
rewards "healthy_224a" [gen_left] G224a=1 : 5*gen_time*ratio_factor; endrewards // generator 224a healthy
rewards "healthy_252a" [gen_left] G252a=1 : 5*gen_time*ratio_factor; endrewards // generator 252a healthy
rewards "time_l" [gen_left] true : gen_time*ratio_factor; endrewards // left side time step
rewards "switches_l" // number of switches of left side
	[c1] true : 1*ratio_factor;
	[c2] true : 1*ratio_factor;
	[c3] true : 1*ratio_factor;
	[c4] true : 1*ratio_factor;
endrewards


//////////////////////////// HIGH VOLATAGE AC, RIGHT (210b) ///////////////////////////////


system "HVAC_RIGHT"
       C5_switch || C6_switch || C7_switch || GEN_RIGHT || RIGHT
endsystem

const C5_init = 1;
const C6_init = 0;
const C7_init = 1;
const C10_init = 1;

module C5_switch = C1_switch [C1=C5, C1_int=C5_int, C1_count=C5_count, C1_init=C5_init, c1=c5, nc_left=nc_right, c2=c6, c3=c6, c4=c6, c8=c6] endmodule
module C6_switch = C1_switch [C1=C6, C1_int=C6_int, C1_count=C6_count, C1_init=C6_init, c1=c6, nc_left=nc_right, c2=c7, c3=c7, c4=c7, c8=c7] endmodule
module C7_switch = C1_switch [C1=C7, C1_int=C7_int, C1_count=C7_count, C1_init=C7_init, c1=c7, nc_left=nc_right, c2=c5, c3=c5, c4=c5, c8=c5] endmodule

module GEN_RIGHT
	// generators
        G224b : [0..1] init 1; // 224b
        G252b : [0..1] init 1; // 252b

	[gen_right] true -> (G224b'=1) & (G252b'=1); // both generators work
	[gen_right] true -> (G224b'=1) & (G252b'=0); // AR fails
	[gen_right] true -> (G224b'=0) & (G252b'=1); // GR fails
//	[gen_right] true -> (G224b'=0) & (G252b'=0); // both generators fail
endmodule

// interface I1 (right to left direction)
formula i1r_pow = B214b1=1 & safe_right;
formula i1r_off = (C5=0 & C5_int=0 & C7=0 & C7_int=0) | (C5=0 & C5_int=0 & C6=0 & C6_int=0);
formula i1r_unsafe = !i1r_pow & !i1r_off;

// interface I5 (unidirectional, to RU242b1, paralleling allowed)
formula i5_pow = B214b1=1 & safe_right;
formula i5_off = !i5_pow;

// interface I6 (unidirectional, to RU242b2, paralleling allowed)
formula i6_pow = B214b2=1 & safe_right;
formula i6_off = !i6_pow;

module RIGHT
	// buses - dependent
	B214b1 : [0..1] init 1; // 214b-1
	B214b2 : [0..1] init 1; // 214b-2

	// status of power delivered over interface I1 to right side
	I1_right : [0..2] init 0;

	// players / stages:
	// 1: player 1 sets connectors --------------------------------------------------------------|
	// 2: player 2 communicates connector status over interfaces                                 |
	// 5: player 2 sets generator status                                                         | main loop (go to 1 from 7)
	// 6: player 2 receives communication from other interfaces                                  |
	// 7: player 2 performs tau for normal form -------------------------------------------------|
	pR : [1..7] init 2;

	// 1: connectors
	[nc_right!] pR=1 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2);
	[c5!] pR=1 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2);
	[c6!] pR=1 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2);
	[c7!] pR=1 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2);

	// 2: interfaces - output
	[i1r_pow?] pR=2 & i1r_pow -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=3);
	[i1r_off?] pR=2 & i1r_off -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=3);
	[i1r_unsafe?] pR=2 & i1r_unsafe -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=3);

	[i5_pow?] pR=3 & i5_pow -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=4);
	[i5_off?] pR=3 & i5_off -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=4);

	[i6_pow?] pR=4 & i6_pow -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=5);
	[i6_off?] pR=4 & i6_off -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=5);

	// 5: generators
	[gen_right?] pR=5 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=6);

	// 6: interfaces - input
	[i1l_pow?] pR=6 -> (I1_right'=1) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=7);
	[i1l_off?] pR=6 -> (I1_right'=0) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=7);
	[i1l_unsafe?] pR=6 -> (I1_right'=2) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=7);

	// 7: for normal form
	[tau?] pR=7 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=1);
endmodule

// SAFETY SPECIFICATIONS - HVAC RIGHT

// no paralleling of sources
formula safe_right = (C5=0 | I1_right=0) &
	             (C5=0 | C7=0 | C6=0) &
		     (C6=0 | C7=0 | I1_right=0);

// buses
formula bus_214b1 = (I1_right=1) |
	            (G252b=1 & C5=1) |
	            (B214b2=1 & G224b=1 & C7=1 & C6=1)
	            ? 1 : 0;
formula bus_214b2 = (G224b=1 & C6=1) |
	            (B214b1=1 & I1_right=1 & C7=1) |
	            (B214b1=1 & G252b=1 & C5=1 & C7=1)
                    ? 1 : 0;

// REWARDS - HVAC RIGHT

rewards "i1r_pow" [i1r_pow] true : gen_time*ratio_factor; endrewards // right side powers interface 1
rewards "i1r_off" [i1r_off] true : gen_time*ratio_factor; endrewards // right side isolates interface 1
rewards "idcr_pow" [i5_pow] true : gen_time*ratio_factor; [i6_pow] true : gen_time*ratio_factor; endrewards // power is transferred over DC interface i5 or i6
rewards "fail_r" [gen_right] !safe_right : 1*ratio_factor; endrewards // right side fails
rewards "healthy_224b" [gen_right] G224b=1 : gen_time*ratio_factor; endrewards // generator 224b healthy
rewards "healthy_252b" [gen_right] G252b=1 : gen_time*ratio_factor; endrewards // generator 252b healthy
rewards "time_r" [gen_right] true : gen_time*ratio_factor; endrewards // right side time step
rewards "switches_r" // number of switches of right side
	[c5] true : 1*ratio_factor;
	[c6] true : 1*ratio_factor;
	[c7] true : 1*ratio_factor;
endrewards





//////////////////////////// HIGH VOLATAGE DC, RIGHT (240b) ///////////////////////////////


system "HVDC_RIGHT"
       C15_switch || C16_switch || GEN_222b || HVDC_RIGHT
endsystem

const C15_init = 0;
const C16_init = 0;

module C15_switch = C1_switch [C1=C15, C1_int=C15_int, C1_count=C15_count, C1_init=C15_init, c1=c15, nc_left=nc_hvdcr, c2=c16, c3=c16, c4=c16, c8=c16] endmodule
module C16_switch = C1_switch [C1=C16, C1_int=C16_int, C1_count=C16_count, C1_init=C16_init, c1=c16, nc_left=nc_hvdcr, c2=c15, c3=c15, c4=c15, c8=c15] endmodule

module GEN_222b
        G222b : [0..1] init 1; // 222b

	[gen_hvdc_right] true -> (G222b'=1); // generators works
	[gen_hvdc_right] true -> (G222b'=0); // generator fails
endmodule

module HVDC_RIGHT
	// buses - dependent
	B246b : [0..1] init 1; // 246b

	// status of power delivered over interfaces
	I5_right : [0..2] init 0;
	I6_below : [0..1] init 0;
	I7_below : [0..1] init 0;

	// players / stages:
	// 1: player 1 sets connectors --------------------------------------------------------------|
	// 2: player 2 communicates connector status over interfaces                                 |
	// 3: player 2 sets generator status                                                         | main loop (go to 1 from 5)
	// 4: player 2 receives communication from other interfaces                                  |
	// 5: player 2 performs tau for normal form -------------------------------------------------|
	pHVDCr : [1..5] init 3;

	// 1: connectors
	[nc_hvdcr!] pHVDCr=1 -> (B246b'=bus_246b) & (pHVDCr'=3);
	[c15!] pHVDCr=1 -> (B246b'=bus_246b) & (pHVDCr'=3);
	[c16!] pHVDCr=1 -> (B246b'=bus_246b) & (pHVDCr'=3);

	// 3: generators
	[gen_hvdc_right?] pHVDCr=3 -> (B246b'=bus_246b) & (pHVDCr'=5);

	// for normal form
	[tau?] pHVDCr=5 -> (B246b'=bus_246b) & (pHVDCr'=1);
endmodule

// SAFETY SPECIFICATIONS - HVDC RIGHT

// paralleling allowed in DC
formula safe_240b = true;

// buses
formula bus_246b = (I5_right=1 & C15=1) |
	           (G222b=1 & C16=1) |
	           (I6_below=1) |
	           (I7_below=1) ? 1 : 0;

// LABELS FOR SIMULATION
label "safe_left" = safe_left;
//label "healthy_left" = G252a=1 | G224a=1;
//label "parallel_safe_right" = parallel_safe_right;
//label "time_safe_right" = time_safe_right;
//label "safe_right" = safe_right;

