//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
// Electrical Starting, Generation, Conversion and Distribution System Architecture for //
//     a More Electric Vehicle                                                          //
//                                                                                      //
// Modelled after European Patent EP 1 792 379 B1, by Rodney G. Michalko                //
//                                                                                      //
// Author: Clemens Wiltsche, University of Oxford, 2014 (clemens.wiltsche@cs.ox.ac.uk)  //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

// Model Assumptions:
// * Game proceeds in stages: contactor intention changes (P1)
//                            contactor intention resolved (P2)
//                            send over interface (dependent)
//                            change generator status (S)
//                            receive over interface (P2)
//       this consitutes one time step
// * Only one contactor switch intention per subsystem may change at any one time
// * Generators may fail independently, also several at a time
// * Interfaces: The component controlling the contactor only switches it on if the
//       subsystem is not powered, so that no power flows out through the contactor,
//       so that sources are not parallelled.

smg

/////////////////////////////// TOP-LEVEL SYTEM (200) ////////////////////////////////////

system "MEV"
	//"HVAC_LEFT" || "HVAC_RIGHT"
	"HVAC_LEFT"
	//"HVAC_RIGHT"
endsystem

// generator dynamics
const double gen_time = 1;   // every gen_time seconds, the generator status is sampled
const double gen_health = 0.8; // probability of generator being healthy per time step

// gen_time is the number of seconds a switch off or on is delayed with probability d0 or d1 respectively
const double d0 = 0.5; // probability to swith off immediately
const double d1 = 1; // probability to swith on immediately

//////////////////////////// HIGH VOLATAGE AC, LEFT (210a) ///////////////////////////////

// since the games are irreducible, and all states have the same period,
// we can use average rewards instead of ratio rewards, and multiply by
// the period. Note that both states and transitions count.

const double ratio_factor = 6*2/gen_time;

system "HVAC_LEFT"
       C1_switch || C2_switch || C3_switch || C4_switch || GEN_LEFT || HVAC_LEFT
endsystem

const C1_init = 0;
const C2_init = 0;
const C3_init = 0;
const C4_init = 0;

module C1_switch
        C1 : [0..1] init C1_init; // connector status for C1
	C1_int : [0..1] init C1_init; // intention for C1

	// change intention to switch off
	[c1] C1_int!=0 -> d0   : (C1_int'=0) & (C1'=0)
                        + 1-d0 : (C1_int'=0);
	// change intention to switch on
	[c1] C1_int!=1 -> d1   : (C1_int'=1) & (C1'=1)
                        + 1-d1 : (C1_int'=1);

	// resolve connector status
	[tau] true -> (C1'=C1_int);
endmodule
module C2_switch = C1_switch [C1=C2, C1_int=C2_int, C1_init=C2_init, c1=c2] endmodule
module C3_switch = C1_switch [C1=C3, C1_int=C3_int, C1_init=C3_init, c1=c3] endmodule

// switch over interface is special
// C4 should only be switched on if no power could flow out of HVAC_left,
// so due to delays we need to make sure that C1 and C2 are off,
// and their intention is off as well
formula safe_to_open_I1_left = (C1=0 & C1_int=0 & C2=0 & C2_int=0);
module C4_switch
        C4 : [0..1] init C4_init; // connector status for C4
	C4_int : [0..1] init C4_init; // intention for C4

	// change intention to switch off
	[c4] C4_int!=0 &!safe_to_open_I1_left -> d0   : (C4_int'=0) & (C4'=0)
                                               + 1-d0 : (C4_int'=0);
	// change intention to switch on
	[c4] C4_int!=1 & safe_to_open_I1_left -> d1   : (C4_int'=1) & (C4'=1)
                                               + 1-d1 : (C4_int'=1);

	// resolve connector status
	[tau] true -> (C4'=C4_int);
endmodule

module GEN_LEFT
	// generators
        G224a : [0..1] init 1; // 224a
        G252a : [0..1] init 1; // 252a

	[gen_left] true -> gen_health*gen_health         : (G224a'=1) & (G252a'=1)  // both generators work
		         + gen_health*(1-gen_health)     : (G224a'=1) & (G252a'=0)  // AL fails
			 + (1-gen_health)*gen_health     : (G224a'=0) & (G252a'=1)  // GL fails
			 + (1-gen_health)*(1-gen_health) : (G224a'=0) & (G252a'=0); // both generators fail

endmodule

// interface I1 (left to right direction)
formula i1l_pow = C4=0 & B214a2=1;
formula i1l_off = !i1l_pow;

module HVAC_LEFT
	// buses - dependent
	B214a1 : [0..1] init 1; // 214a-1
	B214a2 : [0..1] init 1; // 214a-2

	// status of power delivered over interface I1 to left side
	I1_left : [0..1] init 0;

	// players / stages:
	pL : [1..6] init 3;

	// 1: connectors
	// if generators are powered, need to isolate I1
	[nc_left!] pL=1 & (safe_to_open_I1_left | C4_int=0) -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2); // no change
	[c1!] pL=1 & (safe_to_open_I1_left | C4_int=0) -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);
	[c2!] pL=1 & (safe_to_open_I1_left | C4_int=0) -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);
	[c3!] pL=1 & (safe_to_open_I1_left | C4_int=0) & pL=1 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);
	[c4!] pL=1 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);

	// 3: interfaces - output
	[i1l_pow?] pL=2 & i1l_pow -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=3);
	[i1l_off?] pL=2 & i1l_off -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=3);

	// 4: generators
	[gen_left?] pL=3 -> 0.7 : (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4)
			  + 0.3 : (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=5);

	// 5&6: interfaces - input
	[i1r_pow?] pL=4 -> (I1_left'=1) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=6);
	[i1r_off?] pL=5 -> (I1_left'=0) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=6);

	// 7: tau for normal form
	[tau?] pL=6 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=1);
endmodule


// SAFETY SPECIFICATIONS - HVAC LEFT

// no paralleling of sources
formula safe_left = (C1=0 | C3=0 | C2=0) &
		    (C1=0 | C3=0 | C4=0 | I1_left=0) &
		    (C2=0 | C4=0 | I1_left=0);

// buses
formula bus_214a1 = (G224a=1 & C1=1)
	          | (G252a=1 & C3=1 & C2=1)
	          | (C3=1 & C4=1 & I1_left=1)
	          ? 1 : 0;
formula bus_214a2 = (G224a=1 & C1=1 & C3=1)
	          | (G252a=1 & C2=1)
	          | (C4=1 & I1_left=1)
                  ? 1 : 0;

// REWARDS - HVAC LEFT

rewards "i1_l"
	// left side powers interface
	[i1l_pow] safe_left : gen_time*ratio_factor;
endrewards

rewards "buses_l"
	// both buses on left side are powered
	[i1r_pow] safe_left & B214a1=1 & B214a2=1 : gen_time*ratio_factor; 
	[i1r_off] safe_left & B214a1=1 & B214a2=1 : gen_time*ratio_factor;
endrewards

rewards "fail_l"
	 // left side fails
	[i1r_pow] !safe_left : 1*ratio_factor;
	[i1r_off] !safe_left : 1*ratio_factor;
endrewards


//////////////////////////// HIGH VOLATAGE AC, RIGHT (210b) ///////////////////////////////


system "HVAC_RIGHT"
       C5_switch || C6_switch || C7_switch || C8_switch || GEN_RIGHT || RIGHT
endsystem

const C5_init = 0;
const C6_init = 0;
const C7_init = 0;
const C8_init = 0;

module C5_switch = C1_switch [C1=C5, C1_int=C5_int, C1_count=C5_count, c1=c5, conn_res_left=conn_res_right] endmodule
module C6_switch = C1_switch [C1=C6, C1_int=C6_int, C1_count=C6_count, c1=c6, conn_res_left=conn_res_right] endmodule
module C7_switch = C1_switch [C1=C7, C1_int=C7_int, C1_count=C7_count, c1=c7, conn_res_left=conn_res_right] endmodule

// switch over interface is special
// C8 should only be switched on if no power could flow out of HVAC_right,
// so due to delays we need to make sure that C6 and C6 are off,
// and their intention is off as well
formula safe_to_open_I1_right = (C5=0 & C5_int=0 & C6=0 & C6_int=0);
module C8_switch
        C8 : [0..1] init C8_init; // connector status for C8
	C8_int : [0..1] init C8_init; // intention for C8

	// change intention to switch off
	[c8] C8_int!=0 &!safe_to_open_I1_right -> d0   : (C8_int'=0) & (C8'=0)
                                                + 1-d0 : (C8_int'=0);
	// change intention to switch on
	[c8] C8_int!=1 & safe_to_open_I1_right -> d1   : (C8_int'=1) & (C8'=1)
                                                + 1-d1 : (C8_int'=1);

	// resolve connector status
	[tau] true -> (C8'=C8_int);
endmodule

module GEN_RIGHT
	// generators
        G224b : [0..1] init 1; // 224b
        G252b : [0..1] init 1; // 252b

	[gen_right] true -> gen_health*gen_health         : (G224b'=1) & (G252b'=1)  // both generators work
		          + gen_health*(1-gen_health)     : (G224b'=1) & (G252b'=0)  // AR fails
			  + (1-gen_health)*gen_health     : (G224b'=0) & (G252b'=1)  // GR fails
			  + (1-gen_health)*(1-gen_health) : (G224b'=0) & (G252b'=0); // both generators fail
endmodule

// interface I1 (right to left direction)
formula i1r_pow = B214b1=1 & safe_right;
formula i1r_off = !i1r_pow;

module RIGHT
	// buses - dependent
	B214b1 : [0..1] init 1; // 214b-1
	B214b2 : [0..1] init 1; // 214b-2

	// status of power delivered over interface I1 to right side
	I1_right : [0..1] init 0;

	// players / stages:
	pR : [1..7] init 3; // NEEDS TO BE 2

	// 1: connectors
	[nc_right!] pR=1 & (safe_to_open_I1_right| C8_int=0) -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2); // no change
	[c5!] pR=1 & (safe_to_open_I1_right| C8_int=0) -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2);
	[c6!] pR=1 & (safe_to_open_I1_right| C8_int=0) -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2);
	[c7!] pR=1 & (safe_to_open_I1_right| C8_int=0) -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2);
	[c8!] pR=1 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2);

	// 3: interfaces - output
	[i1r_pow?] pR=2 & i1r_pow -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=3);
	[i1r_off?] pR=2 & i1r_off -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=3);

	// 4: generators
	[gen_right?] pR=3 -> 0.7 : (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=4)
                           + 0.3 : (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=5);

	// 5&6: interfaces - input
	[i1l_pow?] pR=4 -> (I1_right'=1) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=6);
	[i1l_off?] pR=5 -> (I1_right'=0) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=6);

	// 7: for normal form
	[tau?] pR=6 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=1);
endmodule

// SAFETY SPECIFICATIONS - HVAC RIGHT

// no paralleling of sources
formula safe_right = (C5=0 | C8=0 | I1_right=0) &
	             (C5=0 | C7=0 | C6=0) &
		     (C6=0 | C7=0 | C8=0 | I1_right=0);

// buses
formula bus_214b1 = (C8=1 & I1_right=1) |
	            (G252b=1 & C5=1) |
	            (G224b=1 & C7=1 & C6=1)
	            ? 1 : 0;
formula bus_214b2 = (G224b=1 & C6=1) |
	            (I1_right=1 & C7=1 & C8=1) |
	            (G252b=1 & C5=1 & C7=1)
                    ? 1 : 0;

// REWARDS - HVAC RIGHT

rewards "i1_r"
	// right side powers interface
	[i1r_pow] safe_right : gen_time*ratio_factor;
endrewards

rewards "buses_r"
	// both buses on right side are powered
	[i1l_pow] safe_right & B214b1=1 & B214b2=1 : gen_time*ratio_factor; 
	[i1l_off] safe_right & B214b1=1 & B214b2=1 : gen_time*ratio_factor;
endrewards

rewards "fail_r"
	 // right side fails
	[i1l_pow] !safe_right : 1*ratio_factor;
	[i1l_off] !safe_right : 1*ratio_factor;
endrewards
