smg

const max_unpowered_time = 10;

module M
	// environment turns power on or off
	[gl?] safe -> true;
	[al?] safe -> true;
	[ar?] safe -> true;
	[gr?] safe -> true;

	// controller switches connectors
	[c1!] safe -> true;
	[c2!] safe -> true;
	[c3!] safe -> true;
	[c4!] safe -> true;
	[c5!] safe -> true;
	[c6!] safe -> true;
	[c7!] safe -> true;

endmodule

module c1_switch
       C1 : [-1..1] init 0;
       [c1?] p=1 -> (C1'=-1);
       [c1?] p=1 -> (C1'=0);
       [c1?] p=1 -> (C1'=1);
endmodule
module c2_switch = c1_switch [c1=c2, C1=C2] endmodule
module c3_switch = c1_switch [c1=c3, C1=C3] endmodule
module c4_switch = c1_switch [c1=c4, C1=C4] endmodule
module c5_switch = c1_switch [c1=c5, C1=C5] endmodule
module c6_switch = c1_switch [c1=c6, C1=C6] endmodule
module c7_switch = c1_switch [c1=c7, C1=C7] endmodule

module gl_switch
       GL : [0..1] init 1;
       [gl?] p=2 -> (GL'=1);
       [gl?] p=2 -> (GL'=0);
endmodule
module al_switch = gl_switch [gl=al, GL=AL] endmodule
module ar_switch = gl_switch [gl=ar, GL=AR] endmodule
module gr_switch = gl_switch [gl=gr, GL=GR] endmodule

module players
        // player
	p : [1..2] init 1;

       [gl?] true -> (p'=3-p);
       [al?] true -> (p'=3-p);
       [ar?] true -> (p'=3-p);
       [gr?] true -> (p'=3-p);
       [c1?] true -> (p'=3-p);
       [c2?] true -> (p'=3-p);
       [c3?] true -> (p'=3-p);
       [c4?] true -> (p'=3-p);
       [c5?] true -> (p'=3-p);
       [c6?] true -> (p'=3-p);
       [c7?] true -> (p'=3-p);
endmodule

module buses
	// dependent varialbes - buses
	B1 : [0..1];
	B2 : [0..1];
	B3 : [0..1];
	B4 : [0..1];

       [gl?] true -> (B1'=bus1) & (B2'=bus2) & (B3'=bus3) & (B4'=bus4);
       [al?] true -> (B1'=bus1) & (B2'=bus2) & (B3'=bus3) & (B4'=bus4);
       [ar?] true -> (B1'=bus1) & (B2'=bus2) & (B3'=bus3) & (B4'=bus4);
       [gr?] true -> (B1'=bus1) & (B2'=bus2) & (B3'=bus3) & (B4'=bus4);
endmodule

module timer1
       t1 : [0..max_unpowered_time];
       [gl?] B1=0 -> (t1'=t1+1);
       [gl?] B1=1 -> (t1'=0);
       [al?] B1=0 -> (t1'=t1+1);
       [al?] B1=1 -> (t1'=0);
       [ar?] B1=0 -> (t1'=t1+1);
       [ar?] B1=1 -> (t1'=0);
       [gr?] B1=0 -> (t1'=t1+1);
       [gr?] B1=1 -> (t1'=0);
       [c1?] B1=0 -> (t1'=t1+1);
       [c1?] B1=1 -> (t1'=0);
       [c2?] B1=0 -> (t1'=t1+1);
       [c2?] B1=1 -> (t1'=0);
       [c3?] B1=0 -> (t1'=t1+1);
       [c3?] B1=1 -> (t1'=0);
       [c4?] B1=0 -> (t1'=t1+1);
       [c4?] B1=1 -> (t1'=0);
       [c5?] B1=0 -> (t1'=t1+1);
       [c5?] B1=1 -> (t1'=0);
       [c6?] B1=0 -> (t1'=t1+1);
       [c6?] B1=1 -> (t1'=0);
       [c7?] B1=0 -> (t1'=t1+1);
       [c7?] B1=1 -> (t1'=0);
endmodule
module timer4 = timer1 [t1=t4, B1=B4] endmodule

// buses
formula bus1 = (C1=1 & GL=1) | (B2=1 & C3=-1) ? 1 : 0;
formula bus2 = (B1=1 & C3=1) | (C2=1 & AL=1) | (B3=1 & C4=-1) ? 1 : 0;
formula bus3 = (B2=1 & C4=1) | (C5=1 & AR=1) | (B4=1 & C7=-1) ? 1 : 0;
formula bus4 = (B3=1 & C7=1) | (C6=1 & GR=1) ? 1 : 0;

// safety specs
formula safe = assm & time_safe & parallel_safe;

// environment assumption
formula assm = (GL=1 | AL=1 | AR=1 | GR=1);

formula unidirectional = (C1!=-1 & C2!=-1 & C5!=-1 & C6!=-1);
formula parallel1 = !(C1=1 & C3=-1);
formula parallel2 = !(C2=1 & C3=1) &
	            !(C2=1 & C4=-1) &
		    !(C3=1 & C4=-1);
formula parallel3 = !(C5=1 & C4=1) &
	            !(C5=1 & C7=-1) &
		    !(C4=1 & C7=-1);
formula parallel4 = !(C6=1 & C7=1);
formula parallel_safe = unidirectional & parallel1 & parallel2 & parallel3 & parallel4;

// safety-critical timing
formula time1 = (t1 <= max_unpowered_time);
formula time4 = (t4 <= max_unpowered_time);
formula time_safe = time1 & time4;

// labels for simulation
label "parallel_safe" = parallel_safe;
label "time_safe" = time_safe;
label "safe" = safe;
