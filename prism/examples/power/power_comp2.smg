smg

const max_unpowered_time = 3;

const double gen_fail = 0.01;

module LEFT
        // connectors
        C1 : [0..1] init 1;
        C2 : [0..1] init 0;
        C3 : [0..1] init 1;
	// uncontrolled
	C4_left : [0..1] init 0; 

	// generators
        GL : [0..1] init 1;
        AL : [0..1] init 1;

	// buses
	B1 : [0..1];
	B2 : [0..1];

	// players
	pL : [1..5] init 2;

	// timer for critical bus
	t1 : [0..max_unpowered_time] init 0;

	// left side sees connector 4 as an environment variable
	// note - need to discourage P2 to take c4 action
	// i.e. do not include in counted switches here,
	// and encourage environment to make progress
	//[c4_on?] safe_left & (pL=2 | pL=3) -> (C4_left'=1) & (B1'=bus1) & (B2'=bus2) & (pL'=3);
	//[c4_off?] safe_left & (pL=2 | pL=3) -> (C4_left'=0) & (B1'=bus1) & (B2'=bus2) & (pL'=3);
	// bus unpowered - increase time
	//[c4_on?] safe_left & B1=0 & (pL=2) -> (C4_left'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=3);
	//[c4_off?] safe_left & B1=0 & (pL=2) -> (C4_left'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=3);
	// bus powered - reset time
	//[c4_on?] safe_left & B1=1 & (pL=2) -> (C4_left'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=3);
	//[c4_off?] safe_left & B1=1 & (pL=2) -> (C4_left'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=3);
	// for normal form
	[tau?] safe_left & pL=3 -> (B1'=bus1) & (B2'=bus2) &  (pL'=1);

	// controller switches connectors 
	// bus unpowered - increase time
	[c1!] safe_left & B1=0 & pL=1 -> (C1'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=2);
	[c1!] safe_left & B1=0 & pL=1 -> (C1'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=2);
	[c2!] safe_left & B1=0 & pL=1 -> (C2'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=2);
	[c2!] safe_left & B1=0 & pL=1 -> (C2'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=2);
	[c3!] safe_left & B1=0 & pL=1 -> (C3'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=2);
	[c3!] safe_left & B1=0 & pL=1 -> (C3'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=2);

	// bus powered - reset time
	[c1!] safe_left & B1=1 & pL=1 -> (C1'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=2);
	[c1!] safe_left & B1=1 & pL=1 -> (C1'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=2);
	[c2!] safe_left & B1=1 & pL=1 -> (C2'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=2);
	[c2!] safe_left & B1=1 & pL=1 -> (C2'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=2);
	[c3!] safe_left & B1=1 & pL=1 -> (C3'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=2);
	[c3!] safe_left & B1=1 & pL=1 -> (C3'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=2);

	// generators
	// bus unpowered - increase time
	[gen?] safe_left & B1=0 & pL=2 -> (1-gen_fail)*(1-gen_fail) : (GL'=1) & (AL'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=3)  // both generators working
	                                + (1-gen_fail)*gen_fail     : (GL'=1) & (AL'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=3)  // AL fails
				        + gen_fail*(1-gen_fail)     : (GL'=0) & (AL'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=3)  // GL fails
	                                + gen_fail*gen_fail         : (GL'=0) & (AL'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=t1+1) & (pL'=3); // both generators fail

	// bus powered - reset time
	[gen?] safe_left & B1=1 & pL=2 -> (1-gen_fail)*(1-gen_fail) : (GL'=1) & (AL'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=3)  // both generators working
	                                + (1-gen_fail)*gen_fail     : (GL'=1) & (AL'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=3)  // AL fails
				        + gen_fail*(1-gen_fail)     : (GL'=0) & (AL'=1) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=3)  // GL fails
	                                + gen_fail*gen_fail         : (GL'=0) & (AL'=0) & (B1'=bus1) & (B2'=bus2) & (t1'=0) & (pL'=3); // both generators fail

	// vehicle arrives
	[arrive?] pL=2 -> (pL'=5) & (C1'=0) & (C2'=0) & (C3'=0) & (C4_left'=0) & (GL'=0) & (AL'=0) & (B1'=0) & (B2'=0) & (t1'=0);
	[term?] pL=5 -> true;

	// fixing deadlock
	[end!] !safe_left & pL=1 -> (pL'=2); // necessarily leads to failure
	[failure?] !safe_left & (pL=2 | pL=3) -> (pL'=4) & (C1'=0) & (C2'=0) & (C3'=0) & (C4_left'=0) & (GL'=0) & (AL'=0) & (B1'=0) & (B2'=0) & (t1'=0);
	[term?] pL=4 -> true;

endmodule

formula failure = !safe_left | pL=4; // either fail, or in terminal
formula arrived = safe_left & pL=5; // safe arrival


// never on -> always off -> c4on=0, c4off=infty -> on/off = 0
// never off -> always on -> c4on=infty, c4off=0 -> on/off = infty
// hence, P1 wants to max, P2 wants to min
rewards "c4on"
	[c4_on] true : 1;
	[gen] C4_left=1 : 1;
	[c1] C4_left=1 : 1;
	[c2] C4_left=1 : 1;
	[c3] C4_left=1 : 1;
endrewards

rewards "c4off"
	[c4_off] true : 1;
	[gen] C4_left=0 : 1;
	[c1] C4_left=0 : 1;
	[c2] C4_left=0 : 1;
	[c3] C4_left=0 : 1;
endrewards

rewards "failures"
	[failure] true : 1;
endrewards

rewards "arrives"
	[arrive] true : 1;
endrewards

rewards "switches_left"
	[c1] true : 1;
	[c2] true : 1;
	[c3] true : 1;
endrewards

rewards "time"
	[gen] true : 1; // every 1 time unit, the generator status is sampled
	[c1] true : 1; // every 1 time unit, the connector C1 can be changed
	[c2] true : 1; // every 1 time unit, the connector C2 can be changed
	[c3] true : 1; // every 1 time unit, the connector C3 can be changed
endrewards

module RIGHT
        // connectors
        C5 : [0..1] init 0;
        C6 : [0..1] init 0;
        C7 : [0..1] init 0;
	C4_right : [0..1] init 0; // controlled

	// uncontrolled generators
        AR : [0..1] init 1;
        GR : [0..1] init 1;

	// buses
	B3 : [0..1];
	B4 : [0..1];

	// players
	pR : [1..2] init 1;

	// timer for critical buses
	t4 : [0..max_unpowered_time] init 0;

	// controller switches connectors
	[c4_off!] safe_right & pR=1 -> (C4_right'=0) & (B3'=bus3) & (B4'=bus4) & (pR'=2);
	[c4_on!] safe_right & pR=1 -> (C4_right'=1) & (B3'=bus3) & (B4'=bus4) & (pR'=2);
	[c5!] safe_right & pR=1 -> (C5'=0) & (B3'=bus3) & (B4'=bus4) & (pR'=2);
	[c5!] safe_right & pR=1 -> (C5'=1) & (B3'=bus3) & (B4'=bus4) & (pR'=2);
	[c6!] safe_right & pR=1 -> (C6'=0) & (B3'=bus3) & (B4'=bus4) & (pR'=2);
	[c6!] safe_right & pR=1 -> (C6'=1) & (B3'=bus3) & (B4'=bus4) & (pR'=2);
	[c7!] safe_right & pR=1 -> (C7'=0) & (B3'=bus3) & (B4'=bus4) & (pR'=2);
	[c7!] safe_right & pR=1 -> (C7'=1) & (B3'=bus3) & (B4'=bus4) & (pR'=2);

	// generators 
	// bus unpowered - increase time
	[tau?] safe_right & pR=2 & B3=0 -> (AR'=1) & (B3'=bus3) & (B4'=bus4) & (t4'=t4+1) & (pR'=1);
       	[tau?] safe_right & pR=2 & B3=0 -> (AR'=0) & (B3'=bus3) & (B4'=bus4) & (t4'=t4+1) & (pR'=1);
	[tau?] safe_right & pR=2 & B3=0 -> (GR'=1) & (B3'=bus3) & (B4'=bus4) & (t4'=t4+1) & (pR'=1);
       	[tau?] safe_right & pR=2 & B3=0 -> (GR'=0) & (B3'=bus3) & (B4'=bus4) & (t4'=t4+1) & (pR'=1);
	// bus powered - reset time
	[tau?] safe_right & pR=2 & B3=1 -> (AR'=1) & (B3'=bus3) & (B4'=bus4) & (t4'=0) & (pR'=1);
       	[tau?] safe_right & pR=2 & B3=1 -> (AR'=0) & (B3'=bus3) & (B4'=bus4) & (t4'=0) & (pR'=1);
	[tau?] safe_right & pR=2 & B3=1 -> (GR'=1) & (B3'=bus3) & (B4'=bus4) & (t4'=0) & (pR'=1);
       	[tau?] safe_right & pR=2 & B3=1 -> (GR'=0) & (B3'=bus3) & (B4'=bus4) & (t4'=0) & (pR'=1);

	// fixing deadlock
	[term?] !safe_right -> true;
endmodule

system "S1"
       LEFT
endsystem

system "S2"
       RIGHT
endsystem

system
	"S1"
endsystem

// buses
formula bus1 = (GL=1 & C1=1) |
	       (B2=1 & AL=1 & C3=1 & C2=1) |
	       (B2=1 & C3=1 & C4_left=1) ? 1 : 0;
formula bus2 = (B1=1 & GL=1 & C1=1 & C3=1) |
	       (AL=1 & C2=1) |
	       (C4_left=1) ? 1 : 0;
formula bus3 = (C4_right=1) |
	       (AR=1 & C5=1) |
	       (B4=1 & GR=1 & C7=1 & C6=1) ? 1 : 0;
formula bus4 = (GR=1 & C6=1) |
	       (B3=1 & C4_right=1 & C7=1) |
	       (B3=1 & AR=1 & C5=1 & C7=1) ? 1 : 0;

// safety specs
formula safe_left = time_safe_left & parallel_safe_left;
formula safe_right = time_safe_right & parallel_safe_right;

formula source_left = (GL=0 => C1=0) & (AL=0 => C2=0);
formula parallel1 = !(C1=1 & C3=1 & C2=1) & !(C1=1 & C3=1 & C4_left=1);
formula parallel2 = !(C2=1 & C4_left=1);
formula parallel_safe_left = source_left & parallel1 & parallel2;

formula source_right = (AR=0 => C5=0) & (GR=0 => C6=0);
formula parallel3 = !(C4_right=1 & C5=1);
formula parallel4 = !(C4_right=1 & C7=1 & C6=1) & !(C5=1 & C7=1 & C6=1);
formula parallel_safe_right = source_right & parallel3 & parallel4;

// connector 4 only on if powered
formula conn4_left = (C4_left=1 => ((GL=1 & C1=1 & B1=1 & C3=1 & B2=1) | (AL=1 & C2=1 & B2=1)));
formula conn4_right = (C4_right=1 => ((GL=1 & C1=1 & B1=1 & C3=1 & B2=1) | (AL=1 & C2=1 & B2=1)));


// safety-critical timing
formula time1 = (t1 <= max_unpowered_time);
formula time_safe_left = time1;
formula time4 = (t4 <= max_unpowered_time);
formula time_safe_right = time4;

// labels for simulation
label "parallel_safe_left" = parallel_safe_left;
label "time_safe_left" = time_safe_left;
label "safe_left" = safe_left;
//label "parallel_safe_right" = parallel_safe_right;
//label "time_safe_right" = time_safe_right;
//label "safe_right" = safe_right;
