//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
// Electrical Starting, Generation, Conversion and Distribution System Architecture for //
//     a More Electric Vehicle                                                          //
//                                                                                      //
// Modelled after European Patent EP 1 792 379 B1, by Rodney G. Michalko                //
//                                                                                      //
// Author: Clemens Wiltsche, University of Oxford, 2014 (clemens.wiltsche@cs.ox.ac.uk)  //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

// Model Assumptions:
// * Game proceeds in stages: contactor intention changes (P1)
//                            contactor intention resolved (P2)
//                            send over interface (dependent)
//                            change generator status (S)
//                            receive over interface (P2)
//       this consitutes one time step
// * Only one contactor switch intention per subsystem may change at any one time
// * Generators may fail independently, also several at a time
// * Interfaces: The component controlling the contactor only switches it on if the
//       subsystem is not powered, so that no power flows out through the contactor,
//       so that sources are not parallelled.

smg

/////////////////////////////// TOP-LEVEL SYTEM (200) ////////////////////////////////////

system "MEV"
	//"HVAC_LEFT" || "HVAC_RIGHT"
	"HVAC_LEFT"
	//"HVAC_RIGHT"
endsystem

// generator dynamics
const double gen_time = 1;   // every gen_time seconds, the reactive loop is performed
const double gen_health = 0.8; // probability of generator being healthy per max_gc time steps
// interface dynamics
const double I1_health = 0.6; // probability of interface being powered

// gen_time is the number of seconds a switch is delayed

// maximum turn-off delay of contactor. max turn-on time is floor(max_delay/2)
const max_delay = 1;
// number of timesteps generator configuration stays the same
const max_gc = 2;

//////////////////////////// HIGH VOLATAGE AC, LEFT (210a) ///////////////////////////////

// since the games are irreducible, and all states have the same period,
// we can use average rewards instead of ratio rewards, and multiply by
// the period. Note that both states and transitions count.

const double ratio_factor = 6*2/gen_time;

system "HVAC_LEFT"
       C1_switch || C2_switch || C3_switch || C4_switch || GEN_LEFT || HVAC_LEFT || GEN_COUNTER_LEFT
endsystem

const C1_init = 0;
const C2_init = 0;
const C3_init = 0;
const C4_init = 0;

module C1_switch
        C1 : [0..1] init C1_init; // connector status for C1
	C1_int : [0..1] init C1_init; // intention for C1
	C1_del : [0..max_delay] init 0; // delay for switching

	// change intention to switch off
	[switch_left] C1_int!=0 -> (C1_int'=0) & (C1_del'=1);
	// change intention to switch on
	[switch_left] C1_int!=1 -> (C1_int'=1) & (C1_del'=ceil(max_delay/2));
	// do nothing
	[switch_left] true -> true;

	// resolve connector status
	[conn_res_left] true -> (C1'=C1_int) & (C1_del'=max_delay);
	// not resolved - increase counter
	[conn_res_left] C1_del<max_delay & (C1!=C1_int) -> (C1_del'=C1_del+1);
endmodule
module C2_switch = C1_switch [C1=C2, C1_int=C2_int, C1_init=C2_init, C1_del=C2_del] endmodule
module C3_switch = C1_switch [C1=C3, C1_int=C3_int, C1_init=C3_init, C1_del=C3_del] endmodule

// switch over interface is special
// C4 should only be switched on if no power could flow out of HVAC_left,
// so due to delays we need to make sure that C1 and C2 are off,
// and their intention is off as well
formula safe_to_open_I1_left = (C1=0 & C1_int=0 & C2=0 & C2_int=0);
module C4_switch
        C4 : [0..1] init C4_init; // connector status for C4
	C4_int : [0..1] init C4_init; // intention for C4
	C4_del : [0..max_delay] init 0; // delay for switching

	// change intention to switch off
	[switch_left] C4_int!=0 &!safe_to_open_I1_left -> (C4_int'=0) & (C4_del'=1);
	// change intention to switch on
	[switch_left] C4_int!=1 & safe_to_open_I1_left -> (C4_int'=1) & (C4_del'=ceil(max_delay/2));
	// no change if save to leave on
	[switch_left] (C4_int=0 | safe_to_open_I1_left) -> true;

	// resolve connector status
	[conn_res_left] true -> (C4'=C4_int) & (C4_del'=max_delay);
	// not resolved - increase counter
	[conn_res_left] C4_del<max_delay & (C4!=C4_int) -> (C4_del'=C4_del+1);
endmodule

module GEN_COUNTER_LEFT
	GC_left : [0..max_gc] init 0;
	
	[gen_left] GC_left<max_gc -> (GC_left'=GC_left+1);
	[gen_left] GC_left=max_gc -> (GC_left'=0);
endmodule

module GEN_LEFT
	// generators
        G224a : [0..1] init 1; // G1
        G252a : [0..1] init 1; // G2

	[gen_left] GC_left=0 -> gen_health*gen_health         : (G224a'=1) & (G252a'=1)  // both generators work
		              + gen_health*(1-gen_health)     : (G224a'=1) & (G252a'=0)  // G2 fails
			      + (1-gen_health)*gen_health     : (G224a'=0) & (G252a'=1)  // G1 fails
		              + (1-gen_health)*(1-gen_health) : (G224a'=0) & (G252a'=0); // both generators fail
	[gen_left] GC_left>0 -> true; // no change in generator status
endmodule

// interface I1 (left to right direction)
formula i1l_pow = C4=0 & B214a2=1;
formula i1l_off = !i1l_pow;

module HVAC_LEFT
	// buses - dependent
	B214a1 : [0..1] init 1; // 214a-1
	B214a2 : [0..1] init 1; // 214a-2

	// status of power delivered over interface I1 to left side
	I1_left : [0..1] init 0;

	// players / stages:
	pL : [1..7] init 4;

	// 1: connectors
	// if generators are powered, need to isolate I1
	[switch_left!] pL=1 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=2);

	// 2: resolve connector status nondeterministically
	[conn_res_left?] pL=2 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=3);

	// 3: interfaces - output (pow_safe or not is determined by HVAC_right)
	[i1l_pow_safe_buses?] pL=3 & safe_left & i1l_pow -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);
	[i1l_pow_buses?] pL=3 & !safe_left & i1l_pow -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);
	[i1l_off_safe_buses?] pL=3 & safe_left & i1l_off -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);
	[i1l_off_buses?] pL=3 & !safe_left & i1l_off -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);

	[i1l_pow_safe?] pL=3 & safe_left & i1l_pow -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);
	[i1l_pow?] pL=3 & !safe_left & i1l_pow -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);
	[i1l_off_safe?] pL=3 & safe_left & i1l_off -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);
	[i1l_off?] pL=3 & !safe_left & i1l_off -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=4);

	// 4: generators
	[gen_left?] pL=4 -> I1_health     : (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=5)
			  + (1-I1_health) : (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=6);

	// 5&6: interfaces - input
	[i1r_pow_safe_buses?] pL=5 & buses_left -> (I1_left'=1) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);
	[i1r_pow_buses?] pL=5 & buses_left -> (I1_left'=1) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);
	[i1r_off_safe_buses?] pL=6 & buses_left -> (I1_left'=0) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);
	[i1r_off_buses?] pL=6 & buses_left -> (I1_left'=0) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);

	[i1r_pow_safe?] pL=5 & !buses_left -> (I1_left'=1) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);
	[i1r_pow?] pL=5 & !buses_left -> (I1_left'=1) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);
	[i1r_off_safe?] pL=6 & !buses_left -> (I1_left'=0) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);
	[i1r_off?] pL=6 & !buses_left -> (I1_left'=0) & (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=7);

	// 7: tau for normal form
	[tau?] pL=7 -> (B214a1'=bus_214a1) & (B214a2'=bus_214a2) & (pL'=1);
endmodule




// SAFETY SPECIFICATIONS - HVAC LEFT

// no paralleling of sources
formula safe_left = (C1=0 | C3=0 | C2=0) &
		    (C1=0 | C3=0 | C4=0 | I1_left=0) &
		    (C2=0 | C4=0 | I1_left=0);

// buses
formula bus_214a1 = (G224a=1 & C1=1)
	          | (G252a=1 & C3=1 & C2=1)
	          | (C3=1 & C4=1 & I1_left=1)
	          ? 1 : 0;
formula bus_214a2 = (G224a=1 & C1=1 & C3=1)
	          | (G252a=1 & C2=1)
	          | (C4=1 & I1_left=1)
                  ? 1 : 0;

// safe and buses powered
formula buses_left = B214a1=1 & B214a2=1;


// REWARDS - HVAC LEFT
// defined over actions

rewards "fail_l"
	// left side fails
	[i1l_pow_buses] true : gen_time*ratio_factor;
	[i1l_off_buses] true : gen_time*ratio_factor;
	[i1l_pow] true : gen_time*ratio_factor;
	[i1l_off] true : gen_time*ratio_factor;
endrewards

rewards "i1_l"
	// left side powers interface
	[i1l_pow_safe_buses] true : gen_time*ratio_factor;
	[i1l_pow_buses] true : gen_time*ratio_factor;
	[i1l_pow_safe] true : gen_time*ratio_factor;
	[i1l_pow] true : gen_time*ratio_factor;
endrewards

rewards "buses_l"
	// both buses on left side are powered
	[i1r_pow_safe_buses] true : gen_time*ratio_factor; 
	[i1r_pow_buses] true : gen_time*ratio_factor; 
	[i1r_off_safe_buses] true : gen_time*ratio_factor;
	[i1r_off_buses] true : gen_time*ratio_factor;
endrewards


//////////////////////////// HIGH VOLATAGE AC, RIGHT (210b) ///////////////////////////////


system "HVAC_RIGHT"
       C5_switch || C6_switch || C7_switch || C8_switch || GEN_RIGHT || RIGHT
endsystem

const C5_init = 0;
const C6_init = 0;
const C7_init = 0;
const C8_init = 0;

module C5_switch = C1_switch [C1=C5, C1_int=C5_int, C1_count=C5_count, C1_del=C5_del, conn_res_left=conn_res_right, switch_left=switch_right] endmodule
module C6_switch = C1_switch [C1=C6, C1_int=C6_int, C1_count=C6_count, C1_del=C6_del, conn_res_left=conn_res_right, switch_left=switch_right] endmodule
module C7_switch = C1_switch [C1=C7, C1_int=C7_int, C1_count=C7_count, C1_del=C7_del, conn_res_left=conn_res_right, switch_left=switch_right] endmodule

// switch over interface is special
// C8 should only be switched on if no power could flow out of HVAC_right,
// so due to delays we need to make sure that C6 and C6 are off,
// and their intention is off as well
formula safe_to_open_I1_right = (C5=0 & C5_int=0 & C6=0 & C6_int=0);
module C8_switch
        C8 : [0..1] init C8_init; // connector status for C8
	C8_int : [0..1] init C8_init; // intention for C8
	C8_del : [0..1] init 0; // delay for switching

	// change intention to switch off
	[switch_right] C8_int!=0 &!safe_to_open_I1_right -> (C8_int'=0) & (C8_del'=0);
	// change intention to switch on
	[switch_right] C8_int!=1 & safe_to_open_I1_right -> (C8_int'=1) & (C8_del'=max_delay);
	// no change if save to leave on
	[switch_right] (C8_int=0 | safe_to_open_I1_right) -> true;

	// resolve connector status
	[conn_res_right] C8_int=0 -> (C8'=0) & (C8_del'=max_delay);
	[conn_res_right] C8_int=1 -> (C8'=1) & (C8_del'=max_delay);
	// not resolved - increase counter
	[conn_res_right] C8_del=0 & (C8!=C8_int) -> (C8_del'=max_delay); // next time have to resolve
endmodule

module GEN_RIGHT
	// generators
        G224b : [0..1] init 1; // 224b
        G252b : [0..1] init 1; // 252b

	[gen_right] true -> gen_health*gen_health         : (G224b'=1) & (G252b'=1)  // both generators work
		          + gen_health*(1-gen_health)     : (G224b'=1) & (G252b'=0)  // AR fails
			  + (1-gen_health)*gen_health     : (G224b'=0) & (G252b'=1)  // GR fails
			  + (1-gen_health)*(1-gen_health) : (G224b'=0) & (G252b'=0); // both generators fail
endmodule

// interface I1 (right to left direction)
formula i1r_pow = B214b1=1 & safe_right;
formula i1r_off = !i1r_pow;

module RIGHT
	// buses - dependent
	B214b1 : [0..1] init 1; // 214b-1
	B214b2 : [0..1] init 1; // 214b-2

	// status of power delivered over interface I1 to right side
	I1_right : [0..1] init 0;

	// players / stages:
	pR : [1..7] init 4; // NEEDS TO BE 2

	// 1: connectors
	[switch_right!] pR=1 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=2);

	// 2: resolve connector status nondeterministically
	[conn_res_right?] pR=2 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=3);

	// 3: interfaces - output (pow_safe or not is determined by HVAC_left)
	[i1r_pow_safe_pow_safe?] pR=3 & safe_right & i1r_pow -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=4);
	[i1r_pow_pow_safe?] pR=3 & !safe_right & i1r_pow -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=4);
	[i1r_off_pow_safe?] pR=3 & i1r_off -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=4);
	[i1r_pow_safe?] pR=3 & safe_right & i1r_pow -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=4);
	[i1r_pow?] pR=3 & !safe_right & i1r_pow -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=4);
	[i1r_off?] pR=3 & i1r_off -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=4);

	// 4: generators
	[gen_right?] pR=4 -> I1_health     : (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=5)
                           + (1-I1_health) : (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=6);

	// 5&6: interfaces - input
	[i1l_pow_safe_pow_safe?] pR=5 & pow_safe_right -> (I1_right'=1) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=7);
	[i1l_pow_pow_safe?] pR=5 & pow_safe_right-> (I1_right'=1) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=7);
	[i1l_off_pow_safe?] pR=6 & pow_safe_right-> (I1_right'=0) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=7);
	[i1l_pow_safe?] pR=5 & !pow_safe_right -> (I1_right'=1) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=7);
	[i1l_pow?] pR=5 & !pow_safe_right -> (I1_right'=1) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=7);
	[i1l_off?] pR=6 & !pow_safe_right -> (I1_right'=0) & (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=7);

	// 7: for normal form
	[tau?] pR=7 -> (B214b1'=bus_214b1) & (B214b2'=bus_214b2) & (pR'=1);
endmodule

// SAFETY SPECIFICATIONS - HVAC RIGHT

// no paralleling of sources
formula safe_right = (C5=0 | C8=0 | I1_right=0) &
	             (C5=0 | C7=0 | C6=0) &
		     (C6=0 | C7=0 | C8=0 | I1_right=0);

// buses
formula bus_214b1 = (C8=1 & I1_right=1) |
	            (G252b=1 & C5=1) |
	            (G224b=1 & C7=1 & C6=1)
	            ? 1 : 0;
formula bus_214b2 = (G224b=1 & C6=1) |
	            (I1_right=1 & C7=1 & C8=1) |
	            (G252b=1 & C5=1 & C7=1)
                    ? 1 : 0;

// safe and buses powered
formula pow_safe_right = safe_right & B214b1=1 & B214b2=1;


// REWARDS - HVAC RIGHT
// defined over actions

rewards "i1_r"
	// right side powers interface
	[i1r_pow_safe_pow_safe] true : gen_time*ratio_factor;
	[i1r_pow_safe] true : gen_time*ratio_factor;
endrewards

rewards "buses_r"
	// both buses on right side are powered
	[i1l_pow_safe_pow_safe] true : gen_time*ratio_factor; 
	[i1l_pow_pow_safe] true : gen_time*ratio_factor; 
	[i1l_off_pow_safe] true : gen_time*ratio_factor;
endrewards
