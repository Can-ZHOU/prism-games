//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
// Reactive Compositional Building Control                                              //
//                                                                                      //
// Modelled after Controlling Energy-Efficient Buildings in the Context of Smart Grid:  //
//     A Cyber Physical System Approach, by Mehdi Maasoumy Haghighi, 2013               //
//                                                                                      //
// Author: Clemens Wiltsche, University of Oxford, 2014 (clemens.wiltsche@cs.ox.ac.uk)  //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

// Model Assumptions:
// * each 5m unit of outside wall has windows of total size window_size square meters
// * all quantities given in SI units unless otherwise indicated
smg

// set point of temperature
const temp_set = 21;

// environment constants
const double height = 3; // room height in meters
const double max_valve_opening = 0.02832*5; // AC power: cubic meters of air volume per second (corresponds to 60x5 cubic feet per minute)
const int initial_temp = 20; // initial room temperature
const double T0 = 47; // discharge air temperature (temperature of air used by AC)
const int window_size = 5; // size of window / door per unit wall
const int outside_temp = 15; // current outside temperature

// disturbance - heat generation inside room due to electrical devices, humans, lighting, etc.
// values from Fig. 2.9
// max is about 2.3 degree per 1h
const double q_max = 2.3/60/60*1000; // TODO: remove factor 1000
// min is about -0.8 degree per 1h
const double q_min = -0.8/60/60*1000; // TODO: remove factor 1000
// mean is about 0.8 degree per 1h
//   hence get distribution by solving for alpha: q_min x alpha + q_max x (1-alpha) = 0.8/60/60
const double beta = (0.8/60/60 - q_max) / (q_min - q_max);

// physical constants
const double cpa = 1.007; // specific heat of air
const double rho_pa = 1.2041; // density of air at 20 degree Celsius ("room temperature")
const double rvalue_conversion = 1/5.71/0.0254; // conversion from US R-value to SI units
const double Rw = 10 * rvalue_conversion; // 1.659; // wall resistance
const double Rgl = 5 * rvalue_conversion; //0.124; // glass window resistance
const double Ri = 0.17 * rvalue_conversion; //0.062; // inside air film resistance
const double Ro = 0.61 * rvalue_conversion; //2.149; // outside air film resistance
const double h_open = 0.2; // unforced convection heat transfer coefficient for open window

// dependent physical constants
const double Ri_unit = (Ri + Rw + Ri)/(height*5); // resistance between inside rooms per unit wall segment length of 5m
const double Ro_unit = (Ro + Rw + Ri)/(height*5 - window_size); // resistance of outside wall per unit wall segment length of 5m, taking windows into account
const double Rclosed_unit = (Ro + Rgl + Ri)/window_size; // resistance of closed window
const double Ropen_unit = (1/h_open)/window_size; // resistance of open window

// discretisation constants
// temperature discretisation: define a range from min_temp to min_temp+10
const int temp_samples = 50; // number of temperature points
const double temp_granularity = 10/temp_samples; // each temperature point represents temp_granularity centigrades
const int min_temp = 15; // minimum of temperature range (degree Celcius)
// time discretisation
const double period = 30; // temporal sample period (seconds)


// room topology
//
//   5m    5m
// ____________
// |  1  |  2 |   5m
// |_____|____|
// |    3     |   5m
// |__________|

// communication is in turn 1 <-> 2, 1 <-> 3, 2 <-> 3

const int ratio_factor = 6*2;

module room1

	s1 : [0..6] init 0; // control stage

	temp1 : [0..temp_samples] init floor((initial_temp-min_temp) / temp_granularity); // temperature of room 1
	therm1 : [-1..1] init 0; // air flow valve setting of room 1: -1 ... cooling, 0 ... off, 1 ... heating
	draft1 : [0..2] init 0; // number of outside doors or windows open in room 1

	// accumulate neighbors in unit wall (5m) increments, as identity doesn't matter
	neighbors1_temp0 : [0..2] init 0; // unit neighbors at temperature min_temp+0 to min_temp+2
	neighbors1_temp1 : [0..2] init 0; // unit neighbors at temperature min_temp+2 to min_temp+4
	neighbors1_temp2 : [0..2] init 0; // unit neighbors at temperature min_temp+4 to min_temp+6
	neighbors1_temp3 : [0..2] init 0; // unit neighbors at temperature min_temp+6 to min_temp+8
	// all other unit neighbors are at temperature min_temp+8+min_temp+10

	// 0: discretised heat transfer between rooms: 1 -> 2,3
	[r1_0?] s1=0 & temperature1<min_temp+2 -> (s1'=1);
	[r1_1?] s1=0 & temperature1>=min_temp+2 & temperature1<min_temp+4 -> (s1'=1);
	[r1_2?] s1=0 & temperature1>=min_temp+4 & temperature1<min_temp+6 -> (s1'=1);
	[r1_3?] s1=0 & temperature1>=min_temp+6 & temperature1<min_temp+8 -> (s1'=1);
	[r1_4?] s1=0 & temperature1>=min_temp+8 -> (s1'=1);

	// 1: discretised heat transfer between rooms: 2 -> 1,3
	[r2_0?] s1=1 -> (neighbors1_temp0'=neighbors1_temp0+1) & (s1'=2);
	[r2_1?] s1=1 -> (neighbors1_temp1'=neighbors1_temp1+1) & (s1'=2);
	[r2_2?] s1=1 -> (neighbors1_temp2'=neighbors1_temp2+1) & (s1'=2);
	[r2_3?] s1=1 -> (neighbors1_temp3'=neighbors1_temp3+1) & (s1'=2);
	[r2_4?] s1=1 -> (s1'=2);

	// 2: discretised heat transfer between rooms: 3 -> 2,3
	[r3_0?] s1=2 -> (neighbors1_temp0'=neighbors1_temp0+1) & (s1'=3);
	[r3_1?] s1=2 -> (neighbors1_temp1'=neighbors1_temp1+1) & (s1'=3);
	[r3_2?] s1=2 -> (neighbors1_temp2'=neighbors1_temp2+1) & (s1'=3);
	[r3_3?] s1=2 -> (neighbors1_temp3'=neighbors1_temp3+1) & (s1'=3);
	[r3_4?] s1=2 -> (s1'=3);

	// 3: doors or windows opening
	[draft1_closed?] s1=3 -> (s1'=4) & (draft1'=0);
	//[draft1_open?] s1=3 -> (s1'=4) & (draft1'=1);

	// 5: tau for normal form
	[tau?] s1=4 -> (s1'=5);

	// 4: control AC fan - and reset communication
	//[set1_cool!] s1=5 -> (s1'=6) & (therm1'=-2) & (neighbors1_temp0'=0) & (neighbors1_temp1'=0) & (neighbors1_temp2'=0) & (neighbors1_temp3'=0);
	//[set1_cool!] s1=5 -> (s1'=6) & (therm1'=-1) & (neighbors1_temp0'=0) & (neighbors1_temp1'=0) & (neighbors1_temp2'=0) & (neighbors1_temp3'=0);
	[set1_off!]  s1=5 -> (s1'=6) & (therm1'= 0) & (neighbors1_temp0'=0) & (neighbors1_temp1'=0) & (neighbors1_temp2'=0) & (neighbors1_temp3'=0);
	[set1_heat!] s1=5 -> (s1'=6) & (therm1'= 1) & (neighbors1_temp0'=0) & (neighbors1_temp1'=0) & (neighbors1_temp2'=0) & (neighbors1_temp3'=0);
	//[set1_heat!] s1=5 -> (s1'=6) & (therm1'= 2) & (neighbors1_temp0'=0) & (neighbors1_temp1'=0) & (neighbors1_temp2'=0) & (neighbors1_temp3'=0);

	// 5: pdate temperature, and apply disturbance
	[set1?] s1=6 & temp1 < floor(10/temp_granularity) -> 	beta     : (s1'=0) & (temp1'=temp1 + ceil(temp1_change_qmin)) + // probability of minimum disturbance
			                                        (1-beta) : (s1'=0) & (temp1'=temp1 + ceil(temp1_change_qmax));  // probability of maximum disturbance
	[set1?] s1=6 & temp1 >= floor(10/temp_granularity) ->	(s1'=0);

endmodule

formula neighbors1_temp4 = 2 - (neighbors1_temp0 + neighbors1_temp1 + neighbors1_temp2 + neighbors1_temp3);

// room properties
const double Vr1 = height*5*5; // volume of room 1
const double Cr1 = rho_pa*Vr1 * cpa; // thermal capacity of room 1

// temperature dynamics
formula temperature1 = min_temp + temp1 * temp_granularity; // actual temperature
formula temperature1_change = // actual temperature change
  (
   ((neighbors1_temp0*(min_temp+1) + neighbors1_temp1*(min_temp+3) + neighbors1_temp2*(min_temp+5) + neighbors1_temp3*(min_temp+7) + neighbors1_temp4*(min_temp+9)) - 2*temperature1) / Ri_unit + // internal temperature change
   2 * (outside_temp-temperature1) / Ro_unit + // outside walls without windows
   (2-draft1) * (outside_temp-temperature1) / Rclosed_unit + // closed windows on outside walls
    draft1 * (outside_temp-temperature1) / Ropen_unit + // open windows on outside walls
    (therm1 > 0 ? 
        max_valve_opening * rho_pa * therm1 * cpa * (T0 - temperature1) // thermostat influence (control action)
                : therm1 < 1 ?
        max_valve_opening * rho_pa * (-therm1) * cpa * (outside_temp - temperature1) // thermostat influence (control action)
                : 0)
  ) / Cr1; // divide by thermal capacity of room

formula t1_1_qmin = period*(temperature1_change + q_min / Cr1) / temp_granularity; // helper variable
formula temp1_change_qmin = // discretised temperature change under minimum disturbance
	(t1_1_qmin - ceil(t1_1_qmin) < 0 ? ceil(t1_1_qmin) - t1_1_qmin : t1_1_qmin - ceil(t1_1_qmin)) // absolute difference
             > 0.5 ?
	floor(t1_1_qmin) : // round down
	ceil(t1_1_qmin); // round up

formula t1_1_qmax = period*(temperature1_change + q_max / Cr1) / temp_granularity; // helper variable
formula temp1_change_qmax = // discretised temperature change under maximum disturbance
	(t1_1_qmax - ceil(t1_1_qmax) < 0 ? ceil(t1_1_qmax) - t1_1_qmax : t1_1_qmax - ceil(t1_1_qmax)) // absolute difference
             > 0.5 ?
	floor(t1_1_qmax) : // round down
	ceil(t1_1_qmax); // round up


rewards "t1c" // actual temperature of room 1
	[tau] true : temperature1_change;
endrewards
rewards "t1q"
	[tau] true : t1_1_qmin * temp_granularity;
endrewards
rewards "t1qcx"
	[tau] true : temp1_change_qmax * temp_granularity;
endrewards
rewards "t1qcn"
	[tau] true : temp1_change_qmin * temp_granularity;
endrewards

// REWARDS

rewards "temperature1" // actual temperature of room 1
	//[set1_cool] true : temperature1 * ratio_factor;
	[set1_off]  true : temperature1 * ratio_factor;
	[set1_heat] true : temperature1 * ratio_factor;
endrewards

rewards "temperature1_deviation" // temperature square deviation from setpoint
	//[set1_cool] true : pow((temperature1 - temp_set), 2) * ratio_factor;
	[set1_off]  true : pow((temperature1 - temp_set), 2) * ratio_factor;
	[set1_heat] true : pow((temperature1 - temp_set), 2) * ratio_factor;
endrewards

// airflow input of AC fan [Mehdi, Section 4.4.4]
formula airflow1 = max_valve_opening * period * 60;
rewards "airflow1"
//	[set1_cool] true : airflow1 * ratio_factor; // cubic meters of air
//	[set1_heat] true : airflow1 * ratio_factor; // cubic meters of air
endrewards

// power consumption of AC fan and discharge air [Mehdi, Section 4.4.4]
const double alpha = 0.5; // fan power constant [kWs^3/kg^3]
const double cp = 1.012; // specific heat capacity of air [kJ/kgC]

rewards "power1"
//	[set1_heat] true : airflow1 * cp * (T0 - outside_temp) + alpha * pow(airflow1, 3);
	true : beta;
endrewards
